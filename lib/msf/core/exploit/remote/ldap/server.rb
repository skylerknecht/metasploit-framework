# -*- coding: binary -*-

module Msf

###
#
# This module exposes methods for querying a remote LDAP service
#
###
module Exploit::Remote::LDAP
module Server
  include Exploit::Remote::SocketServer

  #
  # Initializes an exploit module that serves LDAP requests
  #
  def initialize(info = {})
    super

    register_options(
      [
        OptPort.new('SRVPORT', [true, 'The local port to listen on.', 389]),
        OptPath.new('LDIF_FILE', [ false, "Directory LDIF file path"]),
      ], Exploit::Remote::LDAP::Server
    )

    register_advanced_options(
      [
        OptBool.new('LdapServerUdp', [true, "Serve UDP LDAP requests", true]),
        OptBool.new('LdapServerTcp', [true, "Serve TCP LDAP requests", true])
      ], Exploit::Remote::LDAP::Server
    )
  end

  attr_accessor :service # :nodoc:

  #
  # Read LDIF file - from net-ldap ldapserver.rb#L162
  #
  # @ return [Hash] parsed ldif file
  def read_ldif
    if !datastore['LDIF_FILE'].blank? && File.exists?(datastore['LDIF_FILE'])
      ary = File.readlines(datastore['LDIF_FILE'])
      ldif = {}
      while (line = ary.shift) && line.chomp!
        if line =~ /^dn:[\s]*/i
          dn = $'
          ldif[dn] = {}
          while (attrib = ary.shift) && attrib.chomp! && attrib =~ /^([\w]+)[\s]*:[\s]*/
            ldif[dn][$1.downcase] ||= []
            ldif[dn][$1.downcase] << $'
          end
        end
      end
      return ldif
    else
      nil
    end
  end

  #
  # Handle incoming requests
  # Override this method in modules to take flow control
  #
  def on_request_pdu(cli, pdu)
    service.default_on_request_pdu(cli, pdu)
  end

  #
  # Handle incoming requests
  # Override this method in modules to take flow control
  #
  def on_send_response(cli, data)
    cli.write(data)
  end

  #
  # Starts the server
  #
  def start_service
    begin
      comm = _determine_server_comm(datastore['SRVHOST'])
      self.service = Rex::ServiceManager.start(
        Rex::Proto::LDAP::Server,
        datastore['SRVHOST'],
        datastore['SRVPORT'],
        datastore['LdapServerUdp'],
        datastore['LdapServerTcp'],
        read_ldif,
        comm,
        {'Msf' => framework, 'MsfExploit' => self}
      )

      self.service.on_request_pdu = Proc.new do |cli, data|
        on_request_pdu(cli,data)
      end
      self.service.send_response_proc = Proc.new do |cli, data|
        on_send_response(cli,data)
      end

    rescue ::Errno::EACCES => e
      raise Rex::BindFailed.new(e.message)
    end
  end

  def replicant
    obj = super
    if obj.service
      obj.service.extend(Rex::Service)
      obj.service.ref
    end
    obj
  end

  #
  # Stops the server
  # @param destroy [TrueClass,FalseClass] Dereference the server object
  def stop_service(destroy = false)
    Rex::ServiceManager.stop_service(self.service) if self.service
    if destroy
      self.service = nil if self.service
    end
  end

  #
  # Resets the LDAP server
  #
  def reset_service
    stop_service(true)
    start_service
  end

end
end
end
